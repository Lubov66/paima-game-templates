<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>Open World Game</title>
  <link rel="stylesheet" href="index.css">
</head>

<body>
  <div style="display: flex; flex-direction: column; gap: 16px; align-items: center;">
    <h1>Mine and trade diamonds!</h1>
    <div id="actions" style="margin-bottom: 16px;"></div>
    <table id="mined">
      <tr>
        <th>User nonce</th>
        <th>Amount</th>
        <th>Is diamond?</th>
        <th>Mint ERC1155</th>
      </tr>
    </table>
    <h1 style="padding-top: 24px; border-top: solid black; width: 100%; text-align: center;">DEX</h1>
    <h2>Your valid minted diamonds you can sell</h2>
    <table id="userValidAssets">
      <tr>
        <th>Asset token ID</th>
        <th>Amount</th>
        <th>Create sell order</th>
      </tr>
    </table>
    <h2>Existing valid sell orders</h2>
    <table id="orders"></table>
  </div>
</body>
<script type="module">
  import endpoints, { WalletMode } from "./paimaMiddleware.js";
  import { ethers } from "./ethers.min.js";

  const ASSET_ADDRESS = '0x5FbDB2315678afecb367f032d93F642f64180aa3';
  const DEX_ADDRESS = '0x9fE46736679d2D9a65F0992F2272dE9f3c7fa6e0';

  async function start() {
    const actionsDiv = document.getElementById("actions");
    // Get data for wallet and world
    const provider = new ethers.BrowserProvider(window.ethereum);
    const signer = await provider.getSigner();
    const walletAddress = await signer.getAddress();

    const wallet = await endpoints.userWalletLogin({
      mode: WalletMode.EvmInjected,
      preferBatchedMode: false,
    });
    if (!wallet.success) throw new Error('Wallet Error');

    const user = await endpoints.getUserStats(walletAddress);
    if (!user.success) {
      throw new Error("User Error");
    }
    const assetContract = new ethers.Contract(ASSET_ADDRESS, [
      "function balanceOf(address account, uint256 id) view returns (uint256)",
      "function currentNonce(address user) view returns (uint256)",
      "function isApprovedForAll(address account, address operator) view returns (bool)",
      "function mint(uint256 value, bytes data) public",
      "function setApprovalForAll(address operator, bool approved) public",
    ], signer);
    const dexContract = new ethers.Contract(DEX_ADDRESS, [
      "function createSellOrder(uint256 assetId, uint256 assetAmount, uint256 pricePerAsset) public",
    ], signer);

    const nextNonce = await assetContract.currentNonce(walletAddress) + 1n;
    const isApproved = await assetContract.isApprovedForAll(walletAddress, DEX_ADDRESS);

    let mineButton = document.createElement("button");
    mineButton.innerHTML = "Mine for diamonds";
    mineButton.onclick = () => {
      endpoints.submitMineAttempt().then((x) => {
        if (x.success) {
          mineButton.innerHTML = "Please wait...";
          mineButton.disabled = true;
          setTimeout(() => {
            window.location.reload();
          }, 10 * 1000); // wait 10 seconds
        }
      });
    };
    actionsDiv.appendChild(mineButton);

    if (user?.stats?.currentusertokenid > 1) {
      const table = document.getElementById("mined");
      for (let i = 1; i < user.stats.currentusertokenid; i++) {
        const userToken = (await endpoints.getUserTokenStats(walletAddress, i)).stats[0];
        const row = table.insertRow(i);
        let cell = row.insertCell(0);
        cell.innerHTML = `${i}`;
        cell = row.insertCell(1);
        cell.innerHTML = `${userToken.amount}`;
        cell = row.insertCell(2);
        cell.innerHTML = `${userToken.isdiamond ? "YES" : "no"}`;

        cell = row.insertCell(3);
        let mintButton = document.createElement("button");
        mintButton.style.setProperty("width", "100%");
        if (i > nextNonce) {
          mintButton.innerHTML = "Mint above first";
          mintButton.disabled = true;
        } else if (i == nextNonce) {
          mintButton.innerHTML = "Mint";
          mintButton.onclick = () => {
            mintButton.innerHTML = "Confirm and wait...";
            mintButton.disabled = true;
            assetContract.mint(userToken.amount, "0x").then((x) => {
              window.location.reload();
            });
          };
        } else {
          const id = (await endpoints.getUserAssetStats(walletAddress, i))?.stats?.[0]?.assettokenid;
          mintButton = document.createTextNode(`Minted ID ${JSON.stringify(id)}`);
        }
        cell.appendChild(mintButton);
      }
    }

    const userValidAssets = await endpoints.getUserValidMintedAssets(walletAddress);

    const table = document.getElementById("userValidAssets");
    for (const asset of userValidAssets.stats) {
      const row = table.insertRow();
      let cell = row.insertCell(0);
      cell.innerHTML = `${asset.assettokenid}`;
      cell = row.insertCell(1);
      cell.innerHTML = `${asset.amount}`;
      cell = row.insertCell(2);
      const sellButton = document.createElement("button");
      sellButton.innerHTML = isApproved ? "Sell" : "Approve to sell";
      sellButton.style.setProperty("width", "100%");
      sellButton.onclick = () => {
        if (!isApproved) {
          sellButton.innerHTML = "Confirm and wait...";
          sellButton.disabled = true;
          assetContract.setApprovalForAll(DEX_ADDRESS, true).then((x) => {
            window.location.reload();
          });
          return;
        }

        const price = prompt("Enter price per diamond");
        if (!price) return;
        sellButton.innerHTML = "Confirm and wait...";
        sellButton.disabled = true;
        dexContract.createSellOrder(asset.assettokenid, asset.amount, ethers.parseUnits(price)).then((x) => {
          window.location.reload();
        });
      };
      cell.appendChild(sellButton);
    }
  }

  start().then((r) => r);
</script>

</html>